<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>vue知识总结</title>
	</head>
	<body>
		<script type="text/javascript">
			// ----------1、v-if 和 v-show 的区别----------
			//（1）v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐。
			//（2）v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换。
			//（3）v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译；
			// 	   v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留。
			//（4）v-if有更高的切换消耗，适合运营条件不大可能改变；v-show有更高的初始渲染消耗，适合频繁切换。
			//（5）v-if 的显示隐藏是将DOM元素整个添加或删除，
			// 	   v-show 的显示隐藏是为DOM元素添加css的样式display，设置none或者是block，DOM元素是还存在的
			
			// ----------2、vue中$router和$route的区别----------
			// $route表示当前的路由信息对象，每一个路由都会有一个$route对象，是一个局部的对象，
			// 可以获取对应的name，path，params，query，hash，meta，fullPath等。
			// $router是VueRouter的一个对象，通过Vue.use(VueRouter)和Vu构造函数得到一个router的实例对象，
			// 这个对象中是一个全局的对象，他包含了所有的路由，包含了许多关键的对象和属性。如：$router.push({path:'home'})
			// $router是“路由实例”对象，包括了路由的跳转方法，钩子函数等。
			
			// ----------3、Vue 组件 data 为什么必须是函数----------
			// 因为js本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，
			// 当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 data 作为一个函数返回一个对象，
			// 那么每一个实例的 data 属性都是独立的，不会相互影响了
			
			// ----------4、Vue key的作用----------
			// 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。
			// 使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。
			// 如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，
			// 并且确保它在特定索引下显示已被渲染过的每个元素。
			// 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性
			
			// ----------5、vue.nextTick()的作用----------
			// 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。
			// 所以就衍生出了这个获取更新后的DOM的Vue方法。所以放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js代码；
			
			// 理解：nextTick()，是将回调函数延迟在下一次dom更新数据后调用，简单的理解是：当数据更新了，在dom中渲染后，自动执行该函数，
			
			// Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。
			// $nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM
			
			// （1）Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中，
			// 原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，
			// 所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。
			// 与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载已完成。
			// （2）当项目中你想在改变DOM元素的数据后基于新的dom做点什么，对新DOM一系列的js操作都需要放进Vue.nextTick()的回调函数中；
			// 通俗的理解是：更改数据后当你想立即使用js操作新的视图的时候需要使用它
			// （3）在使用某个第三方插件时 ，希望在vue生成的某些dom动态发生变化时重新应用该插件，也会用到该方法，
			// 这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法。
			
			// Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 
			// 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。
			// 这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。
		</script>
	</body>
</html>
