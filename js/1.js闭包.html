<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>js闭包</title>
</head>
<body>
    <script>
    // 》》》1.闭包的概念《《《 
    // 能够读取其他函数内部变量的函数。
    // 或简单理解为定义在一个函数内部的函数，内部函数持有外部函数内变量的引用。

    // 》》》2.闭包的本质《《《 
    //  在一个函数内部创建另一个函数 

    // 》》》3.闭包的特性《《《 
    //  (1)函数嵌套函数
    //  (2)函数内部可以引用函数外部的参数和变量
    //  (3)参数和变量不会被垃圾回收机制回收
    //  
    //  4.闭包的两种主要形式
    //  (1)函数作为返回值 
        function funcA() { 
            var name = 'Teddy';   
            return function(){// 匿名函数
                return name;
            }
        }
        var funcB = funcA();
        console.log(funcB());//Teddy
        // 解释：在这段代码中，funcA()中的返回值是一个匿名函数，这个函数在funcA()作用域内部，
        // 所以它可以获取funcA()作用域下变量name的值，将这个值作为返回值赋给全局作用域下的变量funcB,
        // 实现了在全局变量下获取到局部变量中的变量的值。

        // ************
        function funcC(){
            var num = 3;
            return function(){
                var n = 0;
                console.log(++n);
                console.log(++num);
            }
        }

        var funcD = funcC();
        funcD();//1   4
        funcD();//1   5
        funcD();//1   6
        // 解释：一般情况下，在函数funcC执行完后，就应该连同它里面的变量一同被销毁，
        // 但是在这个例子中，匿名函数作为funcC的返回值被赋值给了funcD，
        // 这时候相当于funcD=function(){var n = 0 ;  console.log(++n);console.log(++num); }，并且匿名函数内部引用着funcC里的变量num，
        // 所以变量num无法被销毁，而变量n是每次被调用时新创建的，
        // 所以每次funcD执行完后它就把属于自己的变量连同自己一起销毁，
        // 于是乎最后就剩下孤零零的num，于是这里就产生了内存消耗的问题

        // ************
        // 定时器与闭包:写一个for循环，让它按顺序打印出当前循环次数
        for (var i=0;i<5;i++) {
            setTimeout(function(){
                console.log(i)
            },100)
        }//打印出5个5
        // 解释：按照预期它应该依次输出1 2 3 4 5，而结果它输出了五次5，这是为什么呢？
        //原来由于js是单线程的，所以在执行for循环的时候定时器setTimeout被安排到任务队列中排队等待执行，
        //而在等待过程中for循环就已经在执行，等到setTimeout可以执行的时候，
        //for循环已经结束，i的值也已经变成5，所以打印出来五个5

        // 那么我们为了实现预期结果应该怎么改这段代码呢？(如果把for循环里面的var变成let，也能实现预期结果)
        for(var i=0;i<5;i++){
            (function(i){
                setTimeout(function(){
                    console.log(i);
                },100)
            }(i));
        }
        // 0
        // 1
        // 2
        // 3
        // 4
        // 解释：引入闭包来保存变量i，将setTimeout放入立即执行函数中，将for循环中的循环值i作为参数传递，100毫秒后同时打印出1 2 3 4 5

        //那如果我们想实现每隔100毫秒分别依次输出数字，又该怎么改呢?
        for(var i=1;i<5;i++){
            (function(i){
                setTimeout(function(){
                    console.log(i);
                },i * 1000)
            })(i)
        }
        // 解释：在这段代码中，相当于同时启动3个定时器，i*1000是为4个定时器分别设置了不同的时间，
        // 同时启动，但是执行时间不同，每个定时器间隔都是1000毫秒，实现了每隔1000毫秒就执行一次打印的效果。

        // >>>>>>>>>>><<<<<<<开始>>>>>>>>>><<<<<<<<<<<<<<
        // (function(){}())与(function(){})()的区别
        // 这两种写法，都是一种立即执行函数的写法，即IIFE (Immediately Invoked Function Expression)。
        // 这种函数在函数定义的地方就直接执行了。
        // 通常的函数声明和调用分开的写法如下：
        // function foo() {/*...*/}     // 这是定义，Declaration；定义只是让解释器知道其存在，但是不会运行。
        // foo();                       // 这是语句，Statement；解释器遇到语句是会运行它的。

        //普通的函数声明function foo(){}是不会执行的。这里如果直接这样写function foo(){}()解释器会报错的，因为是错误的语法。
        //IIFE函数的调用方式通常是将函数表达式、它的调用操作符、分组操作符放到一个括号内，
        //来告诉解释器这里有一个需要立即执行的函数。否则通常情况下，
        //解析器遇到一个function关键字，都会把它当做是一个函数声明，而不是函数表
        // 如下几种写法都是可以的：

        // (function foo(){/*...*/}());

        // (function foo(){/*...*/})();

        // !function foo() {/*...*/}();

        // +function foo() {/*...*/}();

        // -function foo() {/*...*/}();

        // ~function foo() {/*...*/}();

        // 在需要表达式的场景下，就不需要用括号括起来了：
        // void function(){/*...*/}();

        // var foo = function(){/*...*/}(); 

        // true && function () { /*...*/ }();

        // 0, function () { /*...*/ }();
        //void声明了不需要返回值，第二个则将IIFE函数的返回值赋给了foo。第三、第四个都是明确需要表达式的场景，所以解析器会认识这种写法。

        //上述函数中，最开始的那个括号，可能会由于js中自动分号插入机制而引发问题
        // a  =  b  +  c 
        // ;(function() { 
        // // code 
        // }) ();
        // 如果没有第二行的分号，那么该处有可能被解析为c()而开始执行。所以有的时候，
        // 可能会看到这样的写法：;(function foo(){/*...*/}())，前边的分号可以认为是防御型分号。
        

        // >>>>>>>>>>><<<<<<<<<<<<结束>>>>>>>>>>><<<<<<<<<<<<<

        // (2)闭包作为参数传递
        var num = 15;
        var fn1 = function(x){
            if(x > num){
                console.log(x);
            }
        }
        void function(fn2){
            var num = 100;
            fn2(30);
        }(fn1)
        // 30
        // 解释：在这段代码中，函数fn1作为参数传入立即执行函数中，在执行到fn2(30)的时候，
        // 30作为参数传入fn1中，这时候if(x>num)中的num取的并不是立即执行函数中的num，
        // 而是取创建函数的作用域中的num这里函数创建的作用域是全局作用域下，所以num取的是全局作用域中的值15，即30>15，打印30

       

        // **********************
        // 好处
        // (1)保护函数内的变量安全，实现封装，防止变量流入其他环境发生命名冲突
        // (2)在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）
        // (3)匿名自执行函数可以减少内存消耗

        // 坏处
        // (1)其中一点上面已经有体现了，就是被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏，解决方法是可以在使用完变量后手动为它赋值为null；
        // (2)其次由于闭包涉及跨域访问，所以会导致性能损失，我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响
    </script>
</body>
</html>